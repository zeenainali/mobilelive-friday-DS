"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const fileutils_1 = require("../utils/fileutils");
const fs_1 = require("fs");
const RESULTS_FILE = 'dist/.nx-results';
class WorkspaceResults {
    constructor(command, projects) {
        this.command = command;
        this.projects = projects;
        this.commandResults = {
            command: this.command,
            results: {},
        };
        const resultsExists = fs.existsSync(RESULTS_FILE);
        this.startedWithFailedProjects = false;
        if (resultsExists) {
            try {
                const commandResults = fileutils_1.readJsonFile(RESULTS_FILE);
                this.startedWithFailedProjects = commandResults.command === command;
                if (this.startedWithFailedProjects) {
                    this.commandResults = commandResults;
                    this.invalidateOldResults();
                }
            }
            catch (_a) {
                /**
                 * If we got here it is likely that RESULTS_FILE is not valid JSON.
                 * It is safe to continue, and it does not make much sense to give the
                 * user feedback as the file will be updated automatically.
                 */
            }
        }
    }
    get failedProjects() {
        return Object.entries(this.commandResults.results)
            .filter(([_, result]) => !result)
            .map(([project]) => project);
    }
    get hasFailure() {
        return Object.values(this.commandResults.results).some((result) => !result);
    }
    getResult(projectName) {
        return this.commandResults.results[projectName];
    }
    saveResults() {
        if (Object.values(this.commandResults.results).includes(false)) {
            fileutils_1.writeJsonFile(RESULTS_FILE, this.commandResults);
        }
        else if (fs.existsSync(RESULTS_FILE)) {
            fs_1.unlinkSync(RESULTS_FILE);
        }
    }
    setResult(projectName, result) {
        this.commandResults.results[projectName] = result;
    }
    invalidateOldResults() {
        Object.keys(this.commandResults.results).forEach((projectName) => {
            if (!this.projects[projectName]) {
                delete this.commandResults.results[projectName];
            }
        });
    }
}
exports.WorkspaceResults = WorkspaceResults;
//# sourceMappingURL=workspace-results.js.map