"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const path = require("path");
const resolve = require("resolve");
const shared_1 = require("./shared");
const fileutils_1 = require("../utils/fileutils");
const output_1 = require("../utils/output");
const project_graph_1 = require("../core/project-graph");
const affected_project_graph_1 = require("../core/affected-project-graph");
const file_utils_1 = require("../core/file-utils");
const utils_1 = require("./utils");
const PRETTIER_EXTENSIONS = [
    'ts',
    'js',
    'tsx',
    'jsx',
    'scss',
    'less',
    'css',
    'html',
    'json',
    'md',
    'mdx',
];
function format(command, args) {
    let patterns;
    const { nxArgs } = utils_1.splitArgsIntoNxArgsAndOverrides(args, 'affected');
    try {
        patterns = getPatterns(Object.assign(Object.assign({}, args), nxArgs));
    }
    catch (e) {
        output_1.output.error({
            title: e.message,
            bodyLines: [
                `Pass the SHA range: ${output_1.output.bold(`npm run format:${command} -- --base=SHA1 --head=SHA2`)}`,
                '',
                `Or pass the list of files: ${output_1.output.bold(`npm run format:${command} -- --files="libs/mylib/index.ts,libs/mylib2/index.ts"`)}`,
            ],
        });
        process.exit(1);
    }
    // Chunkify the patterns array to prevent crashing the windows terminal
    const chunkList = chunkify(patterns, 50);
    switch (command) {
        case 'write':
            chunkList.forEach((chunk) => write(chunk));
            break;
        case 'check':
            chunkList.forEach((chunk) => check(chunk));
            break;
    }
}
exports.format = format;
function getPatterns(args) {
    const allFilesPattern = [`"**/*.{${PRETTIER_EXTENSIONS.join(',')}}"`];
    try {
        if (args.all) {
            return allFilesPattern;
        }
        shared_1.printArgsWarning(args);
        const p = shared_1.parseFiles(args);
        let patterns = p.files
            .filter((f) => fileutils_1.fileExists(f))
            .filter((f) => PRETTIER_EXTENSIONS.map((ext) => '.' + ext).includes(path.extname(f)));
        const libsAndApp = args.libsAndApps;
        return libsAndApp
            ? getPatternsFromApps(patterns)
            : patterns.map((f) => `"${f}"`);
    }
    catch (e) {
        return allFilesPattern;
    }
}
function getPatternsFromApps(affectedFiles) {
    const graph = project_graph_1.createProjectGraph();
    const affectedGraph = affected_project_graph_1.filterAffected(graph, file_utils_1.calculateFileChanges(affectedFiles));
    const roots = shared_1.getProjectRoots(Object.keys(affectedGraph.nodes));
    return roots.map((root) => `"${root}/**/*.{${PRETTIER_EXTENSIONS.join(',')}}"`);
}
function chunkify(target, size) {
    return target.reduce((current, value, index) => {
        if (index % size === 0)
            current.push([]);
        current[current.length - 1].push(value);
        return current;
    }, []);
}
function write(patterns) {
    if (patterns.length > 0) {
        child_process_1.execSync(`node "${prettierPath()}" --write ${patterns.join(' ')}`, {
            stdio: [0, 1, 2],
        });
    }
}
function check(patterns) {
    if (patterns.length > 0) {
        try {
            child_process_1.execSync(`node "${prettierPath()}" --list-different ${patterns.join(' ')}`, {
                stdio: [0, 1, 2],
            });
        }
        catch (e) {
            process.exit(1);
        }
    }
}
function prettierPath() {
    const basePath = path.dirname(resolve.sync('prettier', { basedir: __dirname }));
    return path.join(basePath, 'bin-prettier.js');
}
//# sourceMappingURL=format.js.map