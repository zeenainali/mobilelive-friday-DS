"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = require("../utils/typescript");
const file_utils_1 = require("./file-utils");
const project_graph_1 = require("./project-graph");
class TargetProjectLocator {
    constructor(nodes) {
        this.nodes = nodes;
        this._sortedNodeNames = [];
        this._sortedNodeNames = project_graph_1.getSortedProjectNodes(nodes).map(({ name }) => name);
    }
    /**
     * Find a project based on its import
     *
     * @param importExpr
     * @param filePath
     * @param npmScope
     *  Npm scope shouldn't be used finding a project, but, to improve backward
     *  compatibility, we fallback to checking the scope.
     *  This happens in cases where someone has the dist output in their tsconfigs
     *  and typescript will find the dist before the src.
     */
    findProjectWithImport(importExpr, filePath, npmScope) {
        const normalizedImportExpr = importExpr.split('#')[0];
        const resolvedModule = typescript_1.resolveModuleByImport(normalizedImportExpr, filePath);
        return this._sortedNodeNames.find((projectName) => {
            const p = this.nodes[projectName];
            if (!project_graph_1.isWorkspaceProject(p)) {
                return false;
            }
            if (resolvedModule && resolvedModule.startsWith(p.data.root)) {
                return true;
            }
            else {
                const normalizedRoot = file_utils_1.normalizedProjectRoot(p);
                const projectImport = `@${npmScope}/${normalizedRoot}`;
                return normalizedImportExpr.startsWith(projectImport);
            }
        });
    }
}
exports.TargetProjectLocator = TargetProjectLocator;
//# sourceMappingURL=target-project-locator.js.map