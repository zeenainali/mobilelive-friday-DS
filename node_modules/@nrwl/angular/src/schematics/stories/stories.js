"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const schematics_1 = require("@angular-devkit/schematics");
const workspace_1 = require("@nrwl/workspace");
const typescript_1 = require("typescript");
const ast_utils_1 = require("../../utils/ast-utils");
function default_1(schema) {
    return schematics_1.chain([createAllStories(schema.name, schema.generateCypressSpecs)]);
}
exports.default = default_1;
function createAllStories(projectName, generateCypressSpecs) {
    return (tree, context) => {
        context.logger.debug('adding .storybook folder to lib');
        const libPath = workspace_1.getProjectConfig(tree, projectName).sourceRoot + '/lib';
        let moduleFilePaths = [];
        tree.getDir(libPath).visit((filePath) => {
            if (!filePath.endsWith('.module.ts')) {
                return;
            }
            moduleFilePaths.push(filePath);
        });
        return schematics_1.chain(moduleFilePaths.map((filePath) => {
            const file = ast_utils_1.getTsSourceFile(tree, filePath);
            const ngModuleDecorators = ast_utils_1.getDecoratorMetadata(file, 'NgModule', '@angular/core');
            if (ngModuleDecorators.length === 0) {
                throw new schematics_1.SchematicsException(`No @NgModule decorator in ${filePath}`);
            }
            const ngModuleDecorator = ngModuleDecorators[0];
            const syntaxList = ngModuleDecorator.getChildren().find((node) => {
                return node.kind === typescript_1.SyntaxKind.SyntaxList;
            });
            const declarationsPropertyAssignment = syntaxList
                .getChildren()
                .find((node) => {
                return (node.kind === typescript_1.SyntaxKind.PropertyAssignment &&
                    node.getChildren()[0].getText() === 'declarations');
            });
            if (!declarationsPropertyAssignment) {
                throw new schematics_1.SchematicsException(`No declarations array in the @NgModule decorator in ${filePath}`);
            }
            const declaredComponents = declarationsPropertyAssignment
                .getChildren()
                .find((node) => node.kind === typescript_1.SyntaxKind.ArrayLiteralExpression)
                .getChildren()
                .find((node) => node.kind === typescript_1.SyntaxKind.SyntaxList)
                .getChildren()
                .filter((node) => node.kind === typescript_1.SyntaxKind.Identifier)
                .map((node) => node.getText())
                .filter((name) => name.endsWith('Component'));
            const imports = file.statements.filter((statement) => statement.kind === typescript_1.SyntaxKind.ImportDeclaration);
            const componentInfo = declaredComponents.map((componentName) => {
                try {
                    const importStatement = imports.find((statement) => {
                        const namedImports = statement
                            .getChildren()
                            .find((node) => node.kind === typescript_1.SyntaxKind.ImportClause)
                            .getChildren()
                            .find((node) => node.kind === typescript_1.SyntaxKind.NamedImports);
                        if (namedImports === undefined)
                            return false;
                        const importedIdentifiers = namedImports
                            .getChildren()
                            .find((node) => node.kind === typescript_1.SyntaxKind.SyntaxList)
                            .getChildren()
                            .filter((node) => node.kind === typescript_1.SyntaxKind.ImportSpecifier)
                            .map((node) => node.getText());
                        return importedIdentifiers.includes(componentName);
                    });
                    const fullPath = importStatement
                        .getChildren()
                        .find((node) => node.kind === typescript_1.SyntaxKind.StringLiteral)
                        .getText()
                        .slice(1, -1);
                    const path = fullPath.slice(0, fullPath.lastIndexOf('/'));
                    const componentFileName = fullPath.slice(fullPath.lastIndexOf('/') + 1);
                    return { name: componentName, path, componentFileName };
                }
                catch (ex) {
                    context.logger.warn(`Could not generate a story for ${componentName}.  Error: ${ex}`);
                    return undefined;
                }
            });
            const modulePath = filePath.substr(0, filePath.lastIndexOf('/'));
            return schematics_1.chain(componentInfo
                .filter((info) => info !== undefined)
                .map((info) => schematics_1.chain([
                schematics_1.schematic('component-story', {
                    libPath: modulePath,
                    componentName: info.name,
                    componentPath: info.path,
                    componentFileName: info.componentFileName,
                }),
                generateCypressSpecs
                    ? schematics_1.schematic('component-cypress-spec', {
                        projectName,
                        libPath: modulePath,
                        componentName: info.name,
                        componentPath: info.path,
                        componentFileName: info.componentFileName,
                    })
                    : () => { },
            ])));
        }));
    };
}
exports.createAllStories = createAllStories;
//# sourceMappingURL=stories.js.map