'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.isTemplateVariable = isTemplateVariable;
exports.interpolateString = interpolateString;
exports.interpolateComponents = interpolateComponents;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*

<div>
  {t('Check the {{ author }} for more articles', {
    author: <Link to={`/authors/${author.id}`}>{author.name}</Link>
  })}
</div>

*/

// Note that [^] is used rather than . to match any character. This
// is because . doesn't span over multiple lines, whereas [^] does.
var variableRegex = /(\{\{\s[^]+?(?=\s\}\})\s\}\})/g;

/**
 * Returns whether a string is a template variable.
 *
 * @param  {String}    str  A string
 * @return {Boolean}        True if the string is a template variable,
 *                          false if not
 */
function isTemplateVariable(str) {
  return new RegExp(variableRegex).test(str);
}

/**
 * Interpolates a string, replacing template variables with values
 * provided in the scope.
 *
 * @param  {String}    str    A string to be interpolated
 * @param  {Object}    scope  An object with variable names and their
 *                            replacements
 * @return {String}           An interpolated string
 */
function interpolateString(str) {
  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!str) {
    return str;
  }

  // Split string into array with regular text and variables split
  // into separate segments, like ['This is a ', '{{ thing }}', '!']
  var parts = str.split(new RegExp(variableRegex)).filter(function (x) {
    return x;
  });

  // If the only thing we have is a single regular string, just return it as is
  if (parts.length === 1 && isTemplateVariable(parts[0]) === false) {
    return str;
  }

  return parts.map(function (part) {
    if (isTemplateVariable(part) === false) {
      return part;
    }

    var variableName = part.replace(/^\{\{\s/, '').replace(/\s\}\}$/, '');
    if (scope[variableName] === undefined) {
      return part;
    }

    return scope[variableName];
  }).join('');
}

/**
 * Interpolates a string, with support for injecting React components.
 *
 * @param  {String}    str    A string to be interpolated
 * @param  {Object}    scope  An object with variable names and their
 *                            replacements
 * @return {Component}        A React component
 */
function interpolateComponents(str) {
  var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!str) {
    return str;
  }

  // Split string into array with regular text and variables split
  // into separate segments, like ['This is a ', '{{ thing }}', '!']
  var parts = str.split(new RegExp(variableRegex)).filter(function (x) {
    return x;
  });

  // If the only thing we have is a single regular string, just return it as is
  if (parts.length === 1 && isTemplateVariable(parts[0]) === false) {
    return str;
  }

  var interpolatedParts = parts.map(function (part, i) {
    var key = part + '_' + i;

    // Not a template variable, return simple <span> with a string
    if (isTemplateVariable(part) === false) {
      return _react2.default.createElement('span', { key: key }, parts[i]);
    }

    var keyName = part.replace(/^\{\{\s/, '').replace(/\s\}\}$/, '');

    var _keyName$split = keyName.split(/:([^]+)/),
        _keyName$split2 = _slicedToArray(_keyName$split, 2),
        scopeKey = _keyName$split2[0],
        scopeChildren = _keyName$split2[1];

    // No matching scope replacement, return raw string


    if (scope[scopeKey] === undefined) {
      return _react2.default.createElement('span', { key: key }, parts[i]);
    }

    var replacement = scope[scopeKey];

    // If the interpolated scope variable is not a React element, render
    // it as a string inside a <span>
    if (_react2.default.isValidElement(replacement) === false) {
      return _react2.default.createElement('span', { key: key }, String(replacement));
    }

    // Returns a clone of the to-be injected element, passing child content
    // from the scope if it exists
    return scopeChildren === undefined ? _react2.default.cloneElement(replacement, { key: key }) : _react2.default.cloneElement(replacement, { key: key }, scopeChildren);
  });

  return interpolatedParts.length > 1 ? _react2.default.createElement(
    'span',
    null,
    interpolatedParts
  ) : interpolatedParts[0];
}