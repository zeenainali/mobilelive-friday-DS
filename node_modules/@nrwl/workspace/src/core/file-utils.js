"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const fs = require("fs");
const fs_1 = require("fs");
const path = require("path");
const path_1 = require("path");
const workspace_results_1 = require("../command-line/workspace-results");
const app_root_1 = require("../utils/app-root");
const fileutils_1 = require("../utils/fileutils");
const json_diff_1 = require("../utils/json-diff");
const ignore = require('ignore');
class WholeFileChange {
    constructor() {
        this.type = 'WholeFileChange';
    }
}
exports.WholeFileChange = WholeFileChange;
function isWholeFileChange(change) {
    return change.type === 'WholeFileChange';
}
exports.isWholeFileChange = isWholeFileChange;
function calculateFileChanges(files, nxArgs, readFileAtRevision = defaultReadFileAtRevision, ignore = getIgnoredGlobs()) {
    if (ignore) {
        files = files.filter((f) => !ignore.ignores(f));
    }
    return files.map((f) => {
        const ext = path_1.extname(f);
        const _mtime = mtime(`${app_root_1.appRootPath}/${f}`);
        // Memoize results so we don't recalculate on successive invocation.
        return {
            file: f,
            ext,
            mtime: _mtime,
            getChanges: () => {
                if (!nxArgs) {
                    return [new WholeFileChange()];
                }
                if (nxArgs.files && nxArgs.files.includes(f)) {
                    return [new WholeFileChange()];
                }
                switch (ext) {
                    case '.json':
                        const atBase = readFileAtRevision(f, nxArgs.base);
                        const atHead = readFileAtRevision(f, nxArgs.head);
                        try {
                            return json_diff_1.jsonDiff(JSON.parse(atBase), JSON.parse(atHead));
                        }
                        catch (e) {
                            return [new WholeFileChange()];
                        }
                    default:
                        return [new WholeFileChange()];
                }
            },
        };
    });
}
exports.calculateFileChanges = calculateFileChanges;
exports.TEN_MEGABYTES = 1024 * 10000;
function defaultReadFileAtRevision(file, revision) {
    try {
        const fileFullPath = `${app_root_1.appRootPath}${path.sep}${file}`;
        const gitRepositoryPath = child_process_1.execSync('git rev-parse --show-toplevel')
            .toString()
            .trim();
        const filePathInGitRepository = path
            .relative(gitRepositoryPath, fileFullPath)
            .split(path.sep)
            .join('/');
        return !revision
            ? fs_1.readFileSync(file).toString()
            : child_process_1.execSync(`git show ${revision}:${filePathInGitRepository}`, {
                maxBuffer: exports.TEN_MEGABYTES,
            })
                .toString()
                .trim();
    }
    catch (_a) {
        return '';
    }
}
function getFileData(filePath) {
    const stat = fs.statSync(filePath);
    return {
        file: path.relative(app_root_1.appRootPath, filePath).split(path.sep).join('/'),
        ext: path.extname(filePath),
        mtime: stat.mtimeMs,
    };
}
function allFilesInDir(dirName, recurse = true) {
    const ignoredGlobs = getIgnoredGlobs();
    const relDirName = path.relative(app_root_1.appRootPath, dirName);
    if (relDirName && ignoredGlobs.ignores(relDirName)) {
        return [];
    }
    let res = [];
    try {
        fs.readdirSync(dirName).forEach((c) => {
            const child = path.join(dirName, c);
            if (ignoredGlobs.ignores(path.relative(app_root_1.appRootPath, child))) {
                return;
            }
            try {
                const s = fs.statSync(child);
                if (!s.isDirectory()) {
                    // add starting with "apps/myapp/..." or "libs/mylib/..."
                    res.push(getFileData(child));
                }
                else if (s.isDirectory() && recurse) {
                    res = [...res, ...allFilesInDir(child)];
                }
            }
            catch (e) { }
        });
    }
    catch (e) { }
    return res;
}
exports.allFilesInDir = allFilesInDir;
function getIgnoredGlobs() {
    const ig = ignore();
    ig.add(readFileIfExisting(`${app_root_1.appRootPath}/.gitignore`));
    ig.add(readFileIfExisting(`${app_root_1.appRootPath}/.nxignore`));
    return ig;
}
function readFileIfExisting(path) {
    return fs.existsSync(path) ? fs.readFileSync(path, 'UTF-8').toString() : '';
}
function readWorkspaceJson() {
    return fileutils_1.readJsonFile(`${app_root_1.appRootPath}/${workspaceFileName()}`);
}
exports.readWorkspaceJson = readWorkspaceJson;
function cliCommand() {
    return workspaceFileName() === 'angular.json' ? 'ng' : 'nx';
}
exports.cliCommand = cliCommand;
function workspaceFileName() {
    if (fileutils_1.fileExists(`${app_root_1.appRootPath}/angular.json`)) {
        return 'angular.json';
    }
    else {
        return 'workspace.json';
    }
}
exports.workspaceFileName = workspaceFileName;
function defaultFileRead(filePath) {
    return fs_1.readFileSync(`${app_root_1.appRootPath}/${filePath}`, 'UTF-8');
}
exports.defaultFileRead = defaultFileRead;
function readPackageJson() {
    return fileutils_1.readJsonFile(`${app_root_1.appRootPath}/package.json`);
}
exports.readPackageJson = readPackageJson;
function readNxJson() {
    const config = fileutils_1.readJsonFile(`${app_root_1.appRootPath}/nx.json`);
    if (!config.npmScope) {
        throw new Error(`nx.json must define the npmScope property.`);
    }
    return config;
}
exports.readNxJson = readNxJson;
// TODO: Make this list extensible
function rootWorkspaceFileNames() {
    return [`package.json`, workspaceFileName(), `nx.json`, `tsconfig.json`];
}
exports.rootWorkspaceFileNames = rootWorkspaceFileNames;
function readWorkspaceFiles() {
    const workspaceJson = readWorkspaceJson();
    const files = [];
    files.push(...rootWorkspaceFileNames().map((f) => getFileData(`${app_root_1.appRootPath}/${f}`)));
    // Add known workspace files and directories
    files.push(...allFilesInDir(app_root_1.appRootPath, false));
    files.push(...allFilesInDir(`${app_root_1.appRootPath}/tools`));
    // Add files for workspace projects
    Object.keys(workspaceJson.projects).forEach((projectName) => {
        const project = workspaceJson.projects[projectName];
        files.push(...allFilesInDir(`${app_root_1.appRootPath}/${project.root}`));
    });
    return files;
}
exports.readWorkspaceFiles = readWorkspaceFiles;
function readEnvironment(target, projects) {
    const nxJson = readNxJson();
    const workspaceJson = readWorkspaceJson();
    const workspaceResults = new workspace_results_1.WorkspaceResults(target, projects);
    return { nxJson, workspaceJson, workspaceResults };
}
exports.readEnvironment = readEnvironment;
/**
 * Returns the time when file was last modified
 * Returns -Infinity for a non-existent file
 */
function mtime(filePath) {
    if (!fs.existsSync(filePath)) {
        return -Infinity;
    }
    return fs.statSync(filePath).mtimeMs;
}
exports.mtime = mtime;
function normalizedProjectRoot(p) {
    if (p.data && p.data.root) {
        const path = p.data.root.split('/').filter((v) => !!v);
        if (path.length === 1) {
            return path[0];
        }
        // Remove the first part of the path, usually 'libs'
        return path.slice(1).join('/');
    }
    else {
        return '';
    }
}
exports.normalizedProjectRoot = normalizedProjectRoot;
//# sourceMappingURL=file-utils.js.map