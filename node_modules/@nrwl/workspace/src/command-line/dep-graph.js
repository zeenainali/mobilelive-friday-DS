"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
const fs_extra_1 = require("fs-extra");
const http = require("http");
const opn = require("opn");
const path_1 = require("path");
const url = require("url");
const project_graph_1 = require("../core/project-graph");
const app_root_1 = require("../utils/app-root");
const output_1 = require("../utils/output");
// maps file extention to MIME types
const mimeType = {
    '.ico': 'image/x-icon',
    '.html': 'text/html',
    '.js': 'text/javascript',
    '.json': 'application/json',
    '.css': 'text/css',
    '.png': 'image/png',
    '.jpg': 'image/jpeg',
    '.wav': 'audio/wav',
    '.mp3': 'audio/mpeg',
    '.svg': 'image/svg+xml',
    '.pdf': 'application/pdf',
    '.doc': 'application/msword',
    '.eot': 'appliaction/vnd.ms-fontobject',
    '.ttf': 'aplication/font-sfnt',
};
function projectsToHtml(projects, graph, affected) {
    const f = fs_1.readFileSync(path_1.join(__dirname, '../core/dep-graph/dep-graph.html')).toString();
    return f
        .replace(`window.projects = null`, `window.projects = ${JSON.stringify(projects)}`)
        .replace(`window.graph = null`, `window.graph = ${JSON.stringify(graph)}`)
        .replace(`window.affected = null`, `window.affected = ${JSON.stringify(affected)}`);
}
function generateGraph(args, affectedProjects) {
    const graph = project_graph_1.onlyWorkspaceProjects(project_graph_1.createProjectGraph());
    const renderProjects = filterProjects(graph, args.filter, args.exclude);
    if (args.file) {
        let folder = app_root_1.appRootPath;
        let filename = args.file;
        let ext = args.file.replace(/^.*\.(.*)$/, '$1');
        if (ext === 'html') {
            if (filename.includes('/')) {
                const [_match, _folder, _file] = /^(.*)\/([^/]*\.(.*))$/.exec(args.file);
                folder = `${app_root_1.appRootPath}/${_folder}`;
                filename = _file;
            }
            filename = `${folder}/${filename}`;
            const assetsFolder = `${folder}/static`;
            const assets = [];
            fs_extra_1.copySync(path_1.join(__dirname, '../core/dep-graph'), assetsFolder, {
                filter: (src, dest) => {
                    const isntHtml = !/dep-graph\.html/.test(dest);
                    if (isntHtml && dest.includes('.')) {
                        assets.push(dest);
                    }
                    return isntHtml;
                },
            });
            const html = projectsToHtml(renderProjects, graph, affectedProjects).replace(/<(script.*|link.*)="(.*\.(?:js|css))"(><\/script>| \/>?)/g, '<$1="static/$2"$3');
            fs_1.writeFileSync(filename, html);
            output_1.output.success({
                title: `HTML output created in ${folder}`,
                bodyLines: [filename, ...assets],
            });
        }
        else if (ext === 'json') {
            filename = `${folder}/${filename}`;
            fs_1.writeFileSync(filename, JSON.stringify({
                graph,
                affectedProjects,
                criticalPath: affectedProjects,
            }, null, 2));
            output_1.output.success({
                title: `JSON output created in ${folder}`,
                bodyLines: [filename],
            });
        }
        else {
            output_1.output.error({
                title: `Please specify a filename with either .json or .html extension.`,
                bodyLines: [`You provided --file=${args.file}`],
            });
            process.exit(1);
        }
    }
    else {
        startServer(renderProjects, graph, affectedProjects, args.host || '127.0.0.1');
    }
}
exports.generateGraph = generateGraph;
function startServer(projects, graph, affected, host) {
    const html = projectsToHtml(projects, graph, affected);
    const app = http.createServer((req, res) => {
        // parse URL
        const parsedUrl = url.parse(req.url);
        // extract URL path
        // Avoid https://en.wikipedia.org/wiki/Directory_traversal_attack
        // e.g curl --path-as-is http://localhost:9000/../fileInDanger.txt
        // by limiting the path to current directory only
        const sanitizePath = path_1.normalize(parsedUrl.pathname).replace(/^(\.\.[\/\\])+/, '');
        let pathname = path_1.join(__dirname, '../core/dep-graph/', sanitizePath);
        fs_1.exists(pathname, function (exist) {
            if (!exist) {
                // if the file is not found, return 404
                res.statusCode = 404;
                res.end(`File ${pathname} not found!`);
                return;
            }
            // if is a directory, then look for index.html
            if (fs_1.statSync(pathname).isDirectory()) {
                // pathname += '/index.html';
                res.writeHead(200, { 'Content-Type': 'text/html' });
                res.end(html);
                return;
            }
            // read file from file system
            fs_1.readFile(pathname, function (err, data) {
                if (err) {
                    res.statusCode = 500;
                    res.end(`Error getting the file: ${err}.`);
                }
                else {
                    // based on the URL path, extract the file extention. e.g. .js, .doc, ...
                    const ext = path_1.parse(pathname).ext;
                    // if the file is found, set Content-type and send data
                    res.setHeader('Content-type', mimeType[ext] || 'text/plain');
                    res.end(data);
                }
            });
        });
    });
    app.listen(4211, host);
    output_1.output.note({
        title: `Dep graph started at http://${host}:4211`,
    });
    opn(`http://${host}:4211`, {
        wait: false,
    });
}
function filterProjects(graph, filter, exclude) {
    const filteredProjects = Object.values(graph.nodes).filter((p) => {
        const filtered = filter && filter.length > 0
            ? filter.find((f) => hasPath(graph, f, p.name, []) || hasPath(graph, p.name, f, []))
            : true;
        return !exclude
            ? filtered
            : exclude && exclude.indexOf(p.name) === -1 && filtered;
    });
    return filteredProjects;
}
function hasPath(graph, target, node, visited) {
    if (target === node)
        return true;
    for (let d of graph.dependencies[node] || []) {
        if (visited.indexOf(d.target) > -1)
            continue;
        if (hasPath(graph, target, d.target, [...visited, d.target]))
            return true;
    }
    return false;
}
//# sourceMappingURL=dep-graph.js.map