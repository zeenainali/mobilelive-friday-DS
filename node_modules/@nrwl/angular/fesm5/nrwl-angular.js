import { __read, __decorate, __values } from 'tslib';
import { Injectable, NgModule } from '@angular/core';
import { ofType, Actions } from '@ngrx/effects';
import { ROUTER_NAVIGATION } from '@ngrx/router-store';
import { Store } from '@ngrx/store';
import { Observable, of } from 'rxjs';
import { map, concatMap, catchError, groupBy, mergeMap, switchMap, filter, withLatestFrom } from 'rxjs/operators';

function pessimisticUpdate(opts) {
    return function (source) {
        return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.onError)));
    };
}
function optimisticUpdate(opts) {
    return function (source) {
        return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.undoAction)));
    };
}
function fetch(opts) {
    return function (source) {
        if (opts.id) {
            var groupedFetches = source.pipe(mapActionAndState(), groupBy(function (_a) {
                var _b = __read(_a, 2), action = _b[0], store = _b[1];
                return opts.id(action, store);
            }));
            return groupedFetches.pipe(mergeMap(function (pairs) {
                return pairs.pipe(switchMap(runWithErrorHandling(opts.run, opts.onError)));
            }));
        }
        return source.pipe(mapActionAndState(), concatMap(runWithErrorHandling(opts.run, opts.onError)));
    };
}
function navigation(component, opts) {
    return function (source) {
        var nav = source.pipe(mapActionAndState(), filter(function (_a) {
            var _b = __read(_a, 2), action = _b[0], state = _b[1];
            return isStateSnapshot(action);
        }), map(function (_a) {
            var _b = __read(_a, 2), action = _b[0], state = _b[1];
            if (!isStateSnapshot(action)) {
                // Because of the above filter we'll never get here,
                // but this properly type narrows `action`
                return;
            }
            return [
                findSnapshot(component, action.payload.routerState.root),
                state,
            ];
        }), filter(function (_a) {
            var _b = __read(_a, 2), snapshot = _b[0], state = _b[1];
            return !!snapshot;
        }));
        return nav.pipe(switchMap(runWithErrorHandling(opts.run, opts.onError)));
    };
}
function isStateSnapshot(action) {
    return action.type === ROUTER_NAVIGATION;
}
function runWithErrorHandling(run, onError) {
    return function (_a) {
        var _b = __read(_a, 2), action = _b[0], state = _b[1];
        try {
            var r = wrapIntoObservable(run(action, state));
            return r.pipe(catchError(function (e) { return wrapIntoObservable(onError(action, e)); }));
        }
        catch (e) {
            return wrapIntoObservable(onError(action, e));
        }
    };
}
/**
 * @whatItDoes maps Observable<Action | [Action, State]> to
 * Observable<[Action, State]>
 */
function mapActionAndState() {
    return function (source) {
        return source.pipe(map(function (value) {
            var _a = __read(normalizeActionAndState(value), 2), action = _a[0], store = _a[1];
            return [action, store];
        }));
    };
}
/**
 * @whatItDoes Normalizes either a bare action or an array of action and state
 * into an array of action and state (or undefined)
 */
function normalizeActionAndState(args) {
    var _a;
    var action, state;
    if (args instanceof Array) {
        _a = __read(args, 2), action = _a[0], state = _a[1];
    }
    else {
        action = args;
    }
    return [action, state];
}
/**
 * @whatItDoes Provides convenience methods for implementing common operations of persisting data.
 */
var DataPersistence = /** @class */ (function () {
    function DataPersistence(store, actions) {
        this.store = store;
        this.actions = actions;
    }
    /**
     *
     * @whatItDoes Handles pessimistic updates (updating the server first).
     *
     * Update the server implemented naively suffers from race conditions and poor error handling.
     *
     * `pessimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions
     * and forces the developer to handle errors.
     *
     * ## Example:
     *
     * ```typescript
     * @Injectable()
     * class TodoEffects {
     *   @Effect() updateTodo = this.s.pessimisticUpdate<UpdateTodo>('UPDATE_TODO', {
     *     // provides an action and the current state of the store
     *     run(a, state) {
     *       // update the backend first, and then dispatch an action that will
     *       // update the client side
     *       return this.backend(state.user, a.payload).map(updated => ({
     *         type: 'TODO_UPDATED',
     *         payload: updated
     *       }));
     *     },
     *
     *     onError(a, e: any) {
     *       // we don't need to undo the changes on the client side.
     *       // we can dispatch an error, or simply log the error here and return `null`
     *       return null;
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * Note that if you don't return a new action from the run callback, you must set the dispatch property
     * of the effect to false, like this:
     *
     * ```
     * class TodoEffects {
     *   @Effect({dispatch: false})
     *   updateTodo; //...
     * }
     * ```
     */
    DataPersistence.prototype.pessimisticUpdate = function (actionType, opts) {
        return this.actions.pipe(ofType(actionType), withLatestFrom(this.store), pessimisticUpdate(opts));
    };
    /**
     *
     * @whatItDoes Handles optimistic updates (updating the client first).
     *
     * `optimisticUpdate` addresses these problems--it runs all fetches in order, which removes race conditions
     * and forces the developer to handle errors.
     *
     * `optimisticUpdate` is different from `pessimisticUpdate`. In case of a failure, when using `optimisticUpdate`,
     * the developer already updated the state locally, so the developer must provide an undo action.
     *
     * The error handling must be done in the callback, or by means of the undo action.
     *
     * ## Example:
     *
     * ```typescript
     * @Injectable()
     * class TodoEffects {
     *   @Effect() updateTodo = this.s.optimisticUpdate<UpdateTodo>('UPDATE_TODO', {
     *     // provides an action and the current state of the store
     *     run: (a, state) => {
     *       return this.backend(state.user, a.payload);
     *     },
     *
     *     undoAction: (a, e: any) => {
     *       // dispatch an undo action to undo the changes in the client state
     *       return ({
     *         type: 'UNDO_UPDATE_TODO',
     *         payload: a
     *       });
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * Note that if you don't return a new action from the run callback, you must set the dispatch property
     * of the effect to false, like this:
     *
     * ```
     * class TodoEffects {
     *   @Effect({dispatch: false})
     *   updateTodo; //...
     * }
     * ```
     */
    DataPersistence.prototype.optimisticUpdate = function (actionType, opts) {
        return this.actions.pipe(ofType(actionType), withLatestFrom(this.store), optimisticUpdate(opts));
    };
    /**
     *
     * @whatItDoes Handles data fetching.
     *
     * Data fetching implemented naively suffers from race conditions and poor error handling.
     *
     * `fetch` addresses these problems--it runs all fetches in order, which removes race conditions
     * and forces the developer to handle errors.
     *
     * ## Example:
     *
     * ```typescript
     * @Injectable()
     * class TodoEffects {
     *   @Effect() loadTodos = this.s.fetch<GetTodos>('GET_TODOS', {
     *     // provides an action and the current state of the store
     *     run: (a, state) => {
     *       return this.backend(state.user, a.payload).map(r => ({
     *         type: 'TODOS',
     *         payload: r
     *       });
     *     },
     *
     *     onError: (a, e: any) => {
     *       // dispatch an undo action to undo the changes in the client state
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * This is correct, but because it set the concurrency to 1, it may not be performant.
     *
     * To fix that, you can provide the `id` function, like this:
     *
     * ```typescript
     * @Injectable()
     * class TodoEffects {
     *   @Effect() loadTodo = this.s.fetch<GetTodo>('GET_TODO', {
     *     id: (a, state) => {
     *       return a.payload.id;
     *     }
     *
     *     // provides an action and the current state of the store
     *     run: (a, state) => {
     *       return this.backend(state.user, a.payload).map(r => ({
     *         type: 'TODO',
     *         payload: r
     *       });
     *     },
     *
     *     onError: (a, e: any) => {
     *       // dispatch an undo action to undo the changes in the client state
     *       return null;
     *     }
     *   });
     *
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     *
     * With this setup, the requests for Todo 1 will run concurrently with the requests for Todo 2.
     *
     * In addition, if DataPersistence notices that there are multiple requests for Todo 1 scheduled,
     * it will only run the last one.
     */
    DataPersistence.prototype.fetch = function (actionType, opts) {
        return this.actions.pipe(ofType(actionType), withLatestFrom(this.store), fetch(opts));
    };
    /**
     * @whatItDoes Handles data fetching as part of router navigation.
     *
     * Data fetching implemented naively suffers from race conditions and poor error handling.
     *
     * `navigation` addresses these problems.
     *
     * It checks if an activated router state contains the passed in component type, and, if it does, runs the `run`
     * callback. It provides the activated snapshot associated with the component and the current state. And it only runs
     * the last request.
     *
     * ## Example:
     *
     * ```typescript
     * @Injectable()
     * class TodoEffects {
     *   @Effect() loadTodo = this.s.navigation(TodoComponent, {
     *     run: (a, state) => {
     *       return this.backend.fetchTodo(a.params['id']).map(todo => ({
     *         type: 'TODO_LOADED',
     *         payload: todo
     *       }));
     *     },
     *     onError: (a, e: any) => {
     *       // we can log and error here and return null
     *       // we can also navigate back
     *       return null;
     *     }
     *   });
     *   constructor(private s: DataPersistence<TodosState>, private backend: Backend) {}
     * }
     * ```
     */
    DataPersistence.prototype.navigation = function (component, opts) {
        return this.actions.pipe(withLatestFrom(this.store), navigation(component, opts));
    };
    DataPersistence.ctorParameters = function () { return [
        { type: Store },
        { type: Actions }
    ]; };
    DataPersistence = __decorate([
        Injectable()
    ], DataPersistence);
    return DataPersistence;
}());
function findSnapshot(component, s) {
    var e_1, _a;
    if (s.routeConfig && s.routeConfig.component === component) {
        return s;
    }
    try {
        for (var _b = __values(s.children), _c = _b.next(); !_c.done; _c = _b.next()) {
            var c = _c.value;
            var ss = findSnapshot(component, c);
            if (ss) {
                return ss;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return null;
}
function wrapIntoObservable(obj) {
    if (!!obj && obj instanceof Observable) {
        return obj;
    }
    else if (!obj) {
        return of();
    }
    else {
        return of(obj);
    }
}

/**
 * @whatItDoes Provides services for enterprise Angular applications.
 *
 * See {@link DataPersistence} for more information.
 */
var NxModule = /** @class */ (function () {
    function NxModule() {
    }
    NxModule_1 = NxModule;
    NxModule.forRoot = function () {
        return { ngModule: NxModule_1, providers: [DataPersistence] };
    };
    var NxModule_1;
    NxModule = NxModule_1 = __decorate([
        NgModule({})
    ], NxModule);
    return NxModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { DataPersistence, NxModule, fetch, navigation, optimisticUpdate, pessimisticUpdate };
//# sourceMappingURL=nrwl-angular.js.map
